# comp-arch-intro
Репозиторий с заданиями, выполненными на курсе "Архитектура ЭВМ" в университете ИТМО

# **Disassembler**

В рамках данного задания была написана программа-транслятор (дизассемблер), с помощью которой можно преобразовывать машинный код в текст программы на языке ассемблера.

Поддерживается следующий набор команд: RISC-V RV32I, RV32M. Подробнее (volume 1): [https://riscv.org/technical/specifications/](https://riscv.org/technical/specifications/). Кодирование: little endian. Вывод регистров: ABI. Обрабатываются только секции .text, .symtable.

Для каждой строки кода указывается её адрес в hex формате. Обозначения меток достаются из Symbol Table (.symtab). Если название метки не найдено в Symbol Table, то используется следующее обозначение: L%i, например, L2, L34. Нумерация начинается с 0. Для каждой метки перед названием указывается адрес.

Аргументы программе передаются через командную строку:
java Main <имя_входного_elf_файла> <имя_выходного_файла>

Если во входном файле встречается команда, которая не распознается программой, то её следует выводить как unknown_instruction.

Выходной файл состоит из двух частей: .text и .symtab, отделенных друг от друга одной пустой строкой. Сначала идет .text, затем .symtab.

К заданию приложен файл с отчётом (Description.pdf), в котором подробно описываются система кодирования команд RISC-V, структура elf файла (включена только информация, необходимая для реализации дизассемблера) и работа написанного кода, а также приведен список использованных источников.

# **ImageFiltering**
В рамках данного задания была написана программа, производящая пороговую фильтрацию изображения методом Оцу (реализован алгоритм для трёх порогов). Необходимо, чтобы в изображении было как минимум 4 разных уровня интенсивности (4 цвета/оттенка серого). Для распараллеливания использовалась библиотека OpenMP ([Стандарт OpenMP 2.0](https://www.openmp.org//wp-content/uploads/cspec20.pdf)).

Используется следующее правило преобразования оттенков:

`[0 .. f0] -> 0,
[f0+1 .. f1] -> 84,
[f1+1 .. f2] -> 170,
[f2+1 .. 255] -> 255.`

Результат работы программы выводится в выходной файл, а время работы программы и значения найденных порогов - в консоль. В данном случае имеется в виду время работы алгоритма без времени на считывание данных и вывод результата.

Формат входных и выходных изображений: PNM (P5). Во входных и выходных PNM файлах комментарии отсутствуют. Формат хранения:

`P5\n<ширина>  <высота>\n255\n<массив значений оттенков пикселей>`

Аргументы программе передаются через командную строку:

`omp4 <кол-во_потоков> <имя_входного_файла> <имя_выходного_файла>`

где omp4 - имя исполняемого файла.

Число потоков может равняться -1 и больше. 0 соответствует значению числа потоков по умолчанию. -1 - запуск без openmp.

К заданию приложен файл с отчётом (Description.pdf), в котором подробно описываются использованные в коде конструкции OpenMP для распараллеливания команд и работа написанного кода, а также приведен список использованных источников. Также в отчёте описана экспериментальная часть работы: были проведены замеры времени работы программы на моем компьютере на тестовых входных данных (in.pgm), после чего построены графики времени работы программы. Для минимизации влияния степени загруженности процессора другими процессами, время усреднялось по нескольким запускам.
